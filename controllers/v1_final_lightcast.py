import os
import requests
from openai import OpenAI
# from controllers.generate_token import token,update_env_key
# import json
from dotenv import load_dotenv
from pydantic import BaseModel
import pandas as pd
from fastapi.middleware.cors import CORSMiddleware

load_dotenv()
client = OpenAI()
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
access_token = os.getenv('access_token')


from datetime import datetime

def current_date():
    return datetime.now().strftime("%d %B %Y")

class CalendarEvent(BaseModel):
    canvas_window: bool
    post_job: bool


def canvas_flag(history):
    history[0] = {"role": "system", "content": "Extract  a boolean flag 'canvas_window' from the given chat  'True' only when complete job description is generated by assistant. "
                                               "extract the second boolean flag 'post_job' from the give chat if the user requested to post the job description and the assistant responded 'yes it will be posted in a while'."}
    print(history)
    completion = client.beta.chat.completions.parse(
        model="gpt-4o-2024-08-06",
         messages= history,
        #     {"role": "system", "content": "Extract  a boolean flag from the given chat that if the assistant generated any Job description or not"},
        #     {"role": "user", "content": f"{history[1:]}"},
        # ],
        response_format=CalendarEvent,
    )

    event = completion.choices[0].message.parsed
    return event

load_dotenv()



def store_chat_history(chat_messages, chat_id, csv_file="chat_history.csv"):
    """
    Stores OpenAI-style chat messages in a pandas DataFrame against a given ID.
    If the ID exists, the chat will be replaced. Otherwise, a new row will be created.
    The DataFrame is saved to a CSV file.

    Args:
        chat_messages (list): OpenAI-style chat messages (list of dicts).
        chat_id (str or int): Unique ID to associate with the chat.
        csv_file (str): Path to the CSV file where the chat history will be stored. Default is "chat_history.csv".
    """
    # Check if the CSV file exists
    if os.path.exists(csv_file):
        # Load existing chat history
        chat_df = pd.read_csv(csv_file)
    else:
        # Create a new DataFrame if the file does not exist
        chat_df = pd.DataFrame(columns=["id", "chat_history"])

    # Check if the ID exists in the DataFrame
    if chat_id in chat_df["id"].values:
        # Update the existing row
        chat_df.loc[chat_df["id"] == chat_id, "chat_history"] = str(chat_messages)
    else:
        # Add a new row
        new_row = {"id": chat_id, "chat_history": str(chat_messages)}
        chat_df = pd.concat([chat_df, pd.DataFrame([new_row])], ignore_index=True)

    # Save the updated DataFrame back to the CSV file
    chat_df.to_csv(csv_file, index=False)
    print(f"Chat history for ID {chat_id} has been saved to {csv_file}.")

# Example usage


# OpenAI API key
#
# def get_skills_for_job_title(job_title, access_token):
#     url = "https://emsiservices.com/skills/versions/latest/skills"
#     headers = {
#         "Authorization": f"Bearer {access_token}"
#     }
#     params = {
#         "q": job_title,
#         "typeIds": "ST1,ST2,ST3",  # Technical and common skills
#         "fields": "id,name,type",
#         "limit": "10"  # Adjust the limit as needed
#     }
#     response = requests.get(url, headers=headers, params=params)
#     response.raise_for_status()
#     return response.json()
#
#
# # Function to get related skills using skill IDs
# def get_related_skills(skill_ids, access_token):
#     url = "https://emsiservices.com/skills/versions/latest/related"
#     headers = {
#         "Authorization": f"Bearer {access_token}",
#         "Content-Type": "application/json"
#     }
#     payload = {
#         "ids": skill_ids
#     }
#     response = requests.post(url, json=payload, headers=headers)
#     response.raise_for_status()
#     return response.json()
#
# def skills_extract(job_title, access_token):
#     Req_job_title = job_title  # Replace with your desired job title
#
#     try:
#         # Step 1: Get skills for the job title
#         skills_data = get_skills_for_job_title(job_title, access_token)
#         skills = skills_data.get("data", [])
#
#         if not skills:
#             return {"error": f"No skills found for job title '{Req_job_title}'."}
#
#         # Extract skill IDs from the skills data
#         skill_ids = [skill["id"] for skill in skills]
#
#         # Step 2: Get related skills using skill IDs
#         related_skills_data = get_related_skills(skill_ids, access_token)
#         related_skills = related_skills_data.get("data", [])
#
#         if not related_skills:
#             return {"error": "No related skills found."}
#
#         # Prepare related skills for return
#         result = []
#         for skill in related_skills:
#             skill_name = skill.get("name")
#             skill_type = skill.get("type", {}).get("name")
#             skill_url = skill.get("infoUrl")
#             result.append({
#                 "name": skill_name,
#                 "type": skill_type,
#                 "url": skill_url
#             })
#
#         return result
#
#     except requests.exceptions.HTTPError as http_err:
#         return {"error": f"HTTP error occurred: {http_err}"}
#     except Exception as err:
#         return {"error": f"An error occurred: {err}"}


# Tools definition with parameters for the `skills_extract` function
# tools = [
#     {
#         "type": "function",
#         "function": {
#             "name": "skills_extract",
#             "description": "Extract job-specific skills from a query using the Lightcast API.",
#             "parameters": {
#                 "type": "object",
#                 "properties": {
#                     "job_title": {
#                         "type": "string",
#                         "description": "this is the job role or job title of the candidate to be hired. This "
#                                        "paramater is compulsory for the function. this should not be python dictionary form"
#                     },
#                 },
#                 "required": ["job_title"]
#             }
#         }
#     }

# ]



# Initial system message
system_message = {
        "role": "system",
        "content": (
            "You are a helpful DESCON HR assistant. Start conversation with greetings by introducing your name only 1 time 'Hi! I am Descon HR Assistant'"
            " and your response should be conversational throughout."
            "'Do not ask are you looking for a job description for a specific role' or Hello! I am Descon HR Assistant in every response,"
            "you will greet on every response provided by user with connecting words. You will not ask multiple questions from user in one response."
            f"Your job is to provide the Job Description. For this purpose,"
            f" you will get the details from the user by asking 3 ~5 questions related to that job title that can benefit in creating JD, each question should be engaging and connected along with suggestion, and greet user by receiving the information for each question and based on these details "
            f"please Note: 'if user interact with you at start and insist you to create the JD for a specific job title' You will not create the JD at the spot. you will ask 3 ~4 questions that is relevant to craft the Job description."
            "try to use professional skills name, certification name, in skill section if needed."
            "Before generating job description. Do not ask the user multiple questions in one response"
            "and provide a complete detailed job description with professional look by  including professional  job description, key responsibilities, and up to date required relevant skills,qualifications and software. Mentioned about certifications as well if you think it is needed based on job title."
            "After providing the job description. User may ask you for some changes, try to make these changes specific only in that job description that you just provided. Note:  'Do not provide new job description'"
            "unless the user want any other category job description that user asked and provide the desired output that user want."
            f"you will use these details for generating tailored and professional job description."
            f"once you get all the details than you must ask for the application deadline ask user what is the deadline of the application and whatever the user provide time or date use {current_date()} for your knowledge of current date that you will be used in application deadline."
            "and user can even edit your provided job description. after finalizing the job description you should ask your  Shall I proceed to distribute the job posting? if user says yes than respond to user that it will be posted in a moment. thank you. "
            "As you are a DESCON HR Assistant, of a company DESCON, so include company name of DESCON in job description. as you are creating job description for your company."
            "Please note 'Keep the conversation professional, engaging, and clear. Never generate a generic job description without user input or provide a job description unrelated to their request.' "
            "IMPORTANT!! In any case, must ask him specific questions for the job role following are the example questions for an imaginary job role i.e. chemical engineer, but donot stick to these questions only"
            "you can ask other questions instead of these, decide on your own."
            "must ask Which industry or product focus will the Chemical Engineer primarily be working on (e.g., pharmaceuticals, petrochemicals, consumer goods, manufacturing, environmental processes, etc.)?"
            "This will clarify the scope of the role and highlight relevant technical skills and experience. "
            "must ask e.g Are there any regulatory or compliance requirements (e.g., OSHA, EPA, FDA) that are particularly important in this position?"
            "This will ensure the job description includes the necessary certifications or knowledge of industry standards."
            "must ask e.g What level of experience or seniority are you looking for in the Chemical Engineer (e.g., entry-level, mid-level, senior-level)?"
            "This will determine the depth of responsibilities, management duties, and technical expertise needed."
            "must ask  what is the qualification for this etc"
            "must ask what is the salary range of the position., Please note the salary currency must decide based on location of job"
            "must ask what is the job location"
            "must ask what is the deadline for the application"
            " and your response should be conversational throughout  "
            "after providing the job description, you will also provide the justification how did you made this job description by reasoning."

            ""
        )}
def google_search(query):
    serp_api_key = "YOUR_SERP_API_KEY"
    query = "latest cryptocurrency news"
    serp_url = f"https://serpapi.com/search.json?q={query}&api_key={serp_api_key}"

    response = requests.get(serp_url)
    search_results = response.json()

    #top_results = "\n".join([result["title"] + " - " + result["snippet"] for result in search_results["organic_results"][:3]])


    #prompt = f"Summarize the following latest news on cryptocurrency:\n{top_results}"

    completion = client.chat.completions.create(
        model="gpt-4-turbo",
        messages=[{"role": "system", "content": "You are an AI that provides real-time news summaries."},
                  {"role": "user", "content": f"{query}"}]
    )

    print(response["choices"][0]["message"]["content"])

# Conversational bot logic
def conversational_Bot(message):
    completion = client.chat.completions.create(
       model="gpt-4o",
        messages=message,
    #reasoning_effort="medium",
        # tools=tools,
        temperature=0.2

    )
    return completion

def get_chat_by_id(chat_id, csv_file="chat_history.csv"):
    """
    Retrieves the chat corresponding to the given ID from a CSV file.

    Args:
        chat_id (str or int): The unique ID for the chat.
        csv_file (str): Path to the CSV file where the chat history is stored.

    Returns:
        generator: Yields individual messages (dict) from the chat history if the ID is found.
        None: If the ID is not found in the file.
    """
    try:
        # Load the chat history from the CSV file
        history = pd.read_csv(csv_file)

        # Check if the ID exists in the DataFrame
        if chat_id in history["id"].values:
            # Retrieve the corresponding chat history
            chat_history_str = history.loc[history["id"] == chat_id, "chat_history"].values[0]

            # Convert the string representation of the chat history back to a list

            chat_history = eval(chat_history_str)

            # Yield individual messages as separate dictionaries
            for message in chat_history:
                yield message
        else:
            print(f"Chat with ID {chat_id} not found.")
            return None
    except FileNotFoundError:
        print(f"File {csv_file} not found.")
        return None
    except Exception as e:
        print(f"An error occurred: {e}")
        return None

class jd_justification(BaseModel):
    justify: str


# Function to extract skills from the job description using OpenAI
def job_description_justification(chat):
    completion = client.beta.chat.completions.parse(
        model="gpt-4o-2024-08-06",
        messages=[
            {"role": "system", "content": f"You are given with a chat"
                                          f"Your task is to extract the complete job description. when you extract the complete job description."
                                          f"1. justify: you must provide the reasoning like chain of thought how complete job description generated. based on what factors." 

                                          f"If any of the above data is not found in the given chat then leave it as None"},
            {"role": "user", "content": chat},
        ],
        #
        response_format=jd_justification,  # Use the defined subclass here
    )
    # Handle cases where the response is empty or does not contain `justify`
    if completion and completion.choices and completion.choices[0].message.parsed:
        return completion.choices[0].message.parsed.justify
    else:
        return None
    # return completion.choices[0].message.parsed.justify

def generate_bash_script(history):
    system_message = {
        "role": "system",
        "content": (
            "you are expert AI assistant. you are provided with chat. you will provide reasoning how job description created. you will provide reasoning only when complete job description available in chat history.."
        )
    }

    user_message = {
        "role": "user",
        "content": history
    }

    response = client.chat.completions.create(
        model="o3-mini",
        reasoning_effort="medium",
        messages=[system_message, user_message]
    )

    return response.choices[0].message.content  # Returning the generated Bash script

async def jd_generator(query, id):
    message = []
    history = pd.read_csv("chat_history.csv")
    columns = history['id']

    if int(id) in list(columns):
        print("inside if")
        chat_history = get_chat_by_id(int(id), csv_file="chat_history.csv")
        for msg in chat_history:
            message.append(msg)
        new_rol = {"role":"user", "content": query}
        message.append(new_rol)
    elif not int(id) in list(columns):
        print("inside elif")
        message.append(system_message)
        new_rol = {"role":"user", "content": query}
        message.append(new_rol)

    response = conversational_Bot(message)
    content = response.choices[0].message.content
    #print(content)

    print(response.choices[0].message.content)
    print(response.choices[0].message.tool_calls)
    #########################
    if response.choices[0].message.content:
        print(response.choices[0].message.content)
        message.append({"role":"assistant","content":response.choices[0].message.content})
    store_chat_history(message, id)
    return {"chat":response.choices[0].message.content, "canvas_flag": canvas_flag(message)}



